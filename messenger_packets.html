<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Packets of messenger</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="static/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      MathML: {
        extensions: ["content-mathml.js"]
      },
      "HTML-CSS": { webFont: "Neo-Euler" }
    });
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Packets of messenger</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#file_data">FILE_DATA</a></li>
<li><a href="#file_control">FILE_CONTROL</a></li>
<li><a href="#typing">TYPING</a></li>
<li><a href="#action">ACTION</a></li>
<li><a href="#message">MESSAGE</a></li>
<li><a href="#status_message">STATUS_MESSAGE</a></li>
<li><a href="#user_status">USER_STATUS</a></li>
<li><a href="#msi">MSI</a></li>
</ul>
</nav>
<p>This is a description of packets of messenger layer of Tox.</p>
<h2 id="file_data">FILE_DATA</h2>
<p>FileData packet is used to transfer sender's data file to a friend. It holds <code>file_id</code> which is one byte long, means that a tox client can send maximum 256 files concurrently. Also it means that two friends can send 512 files to each other concurrently.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x52</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td><code>file_id</code></td>
</tr>
<tr class="odd">
<td><code>0..1371</code></td>
<td>file data piece</td>
</tr>
</tbody>
</table>
<p>One FileData packet can hold maximum 1371 bytes. To send whole file which is bigger than 1371 bytes, messenger's file sending function need to be called many times. Multiple calling file sending function of messenger must be done by the user of tox protocol, Tox-rs provides only an api for sending a chunk of file data. Also, assembling chunks of file data received by tox protocol must be done by the user of tox protocol. File sending module always checks the length of sent bytes by length of file to send. When the sent bytes exceed the length of file to send, it must stop sending file data.</p>
<h2 id="file_control">FILE_CONTROL</h2>
<p>This packet is used to control transferring sender's file to a friend. If a peer of connection wants to pause, kill, seek or accept transferring file, it must use this packet.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x51</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td>Whether it is sending or receiving, 0 = sender, 1 = receiver</td>
</tr>
<tr class="odd">
<td><code>1</code></td>
<td><code>file_id</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td>Control type: 0 = accept, 1 = pause, 2 = kill, 3 = seek</td>
</tr>
<tr class="odd">
<td><code>8</code></td>
<td>Seek parameter which is only included when <code>control type</code> is seek(3)</td>
</tr>
</tbody>
</table>
<p>When messenger layer is called by user using FILE_CONTROL, it checks:</p>
<ul>
<li>Sending direction value is <code>0</code> or <code>1</code> means 0 = sender, 1 = receiver, others = error</li>
<li>Retrieves <code>file transfer object</code> which holds info of file transferring, if it fails then send FileControl packet to a friend to kill the session.</li>
<li><code>file transfer object</code> is managed by <code>file_id</code> and <code>friend_id</code> and <code>sending direction</code>.</li>
</ul>
<p>FILE_CONTROL do following things:</p>
<ul>
<li>Accept: Accept the request of file sending from a friend. It does:
<ul>
<li>checks if status is not <code>Accepted</code> if it is not <code>Accepted</code> then
<ul>
<li>change status to <code>Transferring</code></li>
</ul></li>
<li>else checks:
<ul>
<li>if status is <code>Pause by friend</code> then toggle status of <code>Pause by friend</code></li>
<li>else error because friend asked me to resume file transfer that wasn't paused.</li>
</ul></li>
<li>updates <code>file transfer object</code></li>
</ul></li>
<li>Pause: Pause the transfer. It does:
<ul>
<li>checks if pause status is <code>Paused by friend</code> or transfer status is not <code>Transferring</code> then error because friend asked me to pause transfer that is already paused.</li>
<li>toggles pause status</li>
<li>updates <code>file transfer object</code></li>
</ul></li>
<li>Kill: Kill the transfer session. It does:
<ul>
<li>updates <code>file transfer object</code></li>
<li>set transfer status to <code>None</code></li>
<li>decreases count of friend's number of sending files</li>
</ul></li>
<li>Seek: Seek to the position. It does:
<ul>
<li>checks if the transfer status is <code>Accepted</code> and the sender of this packet is receiver of file data
<ul>
<li>else error because Seek must be used to session <code>Accepted</code> and Seek packet can only be sent by receiver to seek before resuming broken transfers.</li>
</ul></li>
<li>checks if the position exceeds the file size, if it exceeds
<ul>
<li>error because seek position exceeds file size.</li>
</ul></li>
<li>set <code>requested position</code> and <code>transferred position</code> to seek position.</li>
</ul></li>
<li>else error because invalid file control command.</li>
</ul>
<h2 id="typing">TYPING</h2>
<p>This packet is used to transmit sender's typing status to a friend.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x33</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td>Typing status(0 = not typing, 1 = typing)</td>
</tr>
</tbody>
</table>
<p>It checks if the data is one bytes, and update typing status to the value of data.</p>
<h2 id="action">ACTION</h2>
<p>This packet is used to transmit sender's action message to a friend. Here, action message is a something like an IRC action.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x41</code></td>
</tr>
<tr class="even">
<td><code>0..1372</code></td>
<td>UTF8 byte string</td>
</tr>
</tbody>
</table>
<p>It checks if the action message is empty, if it is then do nothing else sends the action message to the friend. It is C string.</p>
<h2 id="message">MESSAGE</h2>
<p>This packet is used to transmit sender's message to a friend.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x40</code></td>
</tr>
<tr class="even">
<td><code>0..1372</code></td>
<td>UTF8 byte string</td>
</tr>
</tbody>
</table>
<p>There is no zero-length or empty string allowed and if it is then do nothing. It is C string.</p>
<h2 id="status_message">STATUS_MESSAGE</h2>
<p>This packet is used to transmit sender's status message to a friend. Every time a friend become online or my status message is changed, this packet is sent to the friend or to all friends of mine.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x31</code></td>
</tr>
<tr class="even">
<td><code>0..1007</code></td>
<td>UTF8 byte string</td>
</tr>
</tbody>
</table>
<p>If packet is received then call registered callback function to change the status message of the friend and change the status data for the friend. It is C string.</p>
<h2 id="user_status">USER_STATUS</h2>
<p>This packet is used to transmit sender's status to a friend. Every time a friend become online or my status is changed, this packet is sent to the friend or to all friends of mine.</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x32</code></td>
</tr>
<tr class="even">
<td><code>1</code></td>
<td>My status(0 = online, 1 = away, 2 = busy)</td>
</tr>
</tbody>
</table>
<p>When a node receives this packet, it call registered callback function to change the status of the friend.</p>
<h2 id="msi">MSI</h2>
<p>MSI(Media Session Interface) is a protocol to manage audio or video calls to a friend(s). Payload of msi packet consists of three kind of commands: request, error, capabilities.</p>
<ul>
<li>Request does init_call, push call(start call) or pop call(end call).</li>
<li>Error is used to handle errors during processing requests.</li>
<li>Capabilities hold the ability of node related with audio, video.</li>
</ul>
<h5 id="msirequest">MSIRequest</h5>
<pre><code>enum MSIRequest {
    REQU_INIT,
    REQU_PUSH,
    REQU_POP,
}</code></pre>
<h5 id="msierror">MSIError</h5>
<pre><code>enum MSIError {
    MSI_E_NONE,
    MSI_E_INVALID_MESSAGE,
    MSI_E_INVALID_PARAM,
    MSI_E_INVALID_STATE,
    MSI_E_STRAY_MESSAGE,
    MSI_E_SYSTEM,
    MSI_E_HANDLE,
    MSI_E_UNDISCLOSED,
}</code></pre>
<h5 id="msicapabilities">MSICapabilities</h5>
<pre><code>enum MSICapabilities {
    MSI_CAP_S_AUDIO = 4,  // sending audio
    MSI_CAP_S_VIDEO = 8,  // sending video
    MSI_CAP_R_AUDIO = 16, // receiving audio
    MSI_CAP_R_VIDEO = 32, // receiving video
}</code></pre>
<h5 id="msicallstate">MSICallState</h5>
<pre><code>enum MSICallState {
    MSI_CALL_INACTIVE,      // Default
    MSI_CALL_ACTIVE,
    MSI_CALL_REQUESTING,    // when sending call invite
    MSI_CALL_REQUESTED,     // when getting call invite
} MSICallState;</code></pre>
<p>Protocol: |kind [1 byte]| |size [1 byte]| |value [$size bytes]| |...{repeat}| |0 {end byte}|</p>
<p>Serialized form:</p>
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Content</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>1</code></td>
<td><code>0x45</code></td>
</tr>
<tr class="even">
<td><code>0..255</code></td>
<td>payload</td>
</tr>
</tbody>
</table>
<p>Though protocol defines <code>size</code> field, actually every commands's size of <code>value</code> is 1 byte. So, <code>size</code> is for the future extension.</p>
<p>This packet structure can permit for a node to send multiple commands in one packet. For example a node can send packet to a friend to start call with capabilities and errors. The node receiving this packet also can do multiple action on commands in a packet. Because <code>payload</code> size is 255 bytes long, we can send maximum 255 / 3 = 85 commands in a packet. But if there are same kind of commands in a packet, the last command will replace the previous commands.</p>
<p>On receiving this packet, a node does:</p>
<ul>
<li>parse packet: parse it to store commands to data structures.
<ul>
<li>Data structure which holds the result of parsing has 3 fields
<ul>
<li><code>Request</code> holds request command</li>
<li><code>Error</code> holds error during processing commands.</li>
<li><code>Capabilities</code> holds the abilities related with audio or video of a friend.</li>
</ul></li>
<li>If there are same kind of commands in a packet, the last command will replace the previous one.</li>
</ul></li>
<li>Process the <code>Request</code> command in the packet.
<ul>
<li>Init: init a msi sesstion.
<ul>
<li>Check if <code>Capaboilites</code> is empty, if it is then return with error(<code>MSI_E_INVALID_MESSAGE</code>).</li>
<li>If call_state is <code>MSI_CALL_INACTIVE</code> then request a call to a friend.</li>
<li>If call_state is <code>MSI_CALL_ACTIVE</code> then sends packet containing capabilities of us. This is the situation of a friend re-call us, but we are not terminated with previous call.</li>
<li>If call_state is <code>MSI_CALL_REQUESTING</code> or <code>MSI_CALL_REQUESTED</code> then return with error(<code>MSI_E_INVALID_STATE</code>).</li>
</ul></li>
<li>Push: Starts a new call to a friend or change capabilities.
<ul>
<li>Check if <code>Capaboilites</code> is empty, if it is then return with error(<code>MSI_E_INVALID_MESSAGE</code>).</li>
<li>If call_state is <code>MSI_CALL_ACTIVE</code> then check if capabilities are changed from previous value, if it is then change current call's capabilities.</li>
<li>If call_state is <code>MSI_CALL_REQUESTING</code> then starts a new call</li>
<li>If call_state is <code>MSI_CALL_INACTIVE</code> or <code>MSI_CALL_REQUESTED</code> then ignore it.</li>
</ul></li>
<li>Pop: Ends current call
<ul>
<li>If there is a error command in the packet then terminates current call.</li>
<li>If call_state is <code>MSI_CALL_INACTIVE</code> then it is a impossible case. So, terminates process.</li>
<li>If call_state is <code>MSI_CALL_ACTIVE</code> then it is a hang-up of a friend. So, ends call.</li>
<li>If call_state is <code>MSI_CALL_REQUESTING</code> then it is a rejection of call by a friend. So, ends call.</li>
<li>If call_state is <code>MSI_CALL_REQUESTED</code> then it is a cancelling of a call request by a friend. So, ends call.</li>
</ul></li>
</ul></li>
</ul>
<p>When we need to send a packet to a friend, a node does:</p>
<ul>
<li>creates a new message object which is one of these:
<ul>
<li>Init</li>
<li>Push</li>
<li>Pop</li>
</ul></li>
<li>adds error if there is an error</li>
<li>adds capabilites of us</li>
<li>makes a packet and sends it using <code>NetCrypto</code></li>
</ul>
</body>
</html>
