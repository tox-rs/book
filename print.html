<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tox Human Docs</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="src/static/table.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="crypto/crypto.html"><strong aria-hidden="true">1.</strong> Cryptography</a></li><li class="chapter-item expanded "><a href="dht/dht.html"><strong aria-hidden="true">2.</strong> DHT</a></li><li class="chapter-item expanded "><a href="relay/relay.html"><strong aria-hidden="true">3.</strong> TCP Relay</a></li><li class="chapter-item expanded "><a href="onion/onion.html"><strong aria-hidden="true">4.</strong> Onion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="onion/client.html"><strong aria-hidden="true">4.1.</strong> Onion client</a></li></ol></li><li class="chapter-item expanded "><a href="messenger/messenger.html"><strong aria-hidden="true">5.</strong> Messenger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="messenger/packets.html"><strong aria-hidden="true">5.1.</strong> Messenger packets</a></li><li class="chapter-item expanded "><a href="messenger/conferences/conferences.html"><strong aria-hidden="true">5.2.</strong> Conferences</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="messenger/conference/packets.html"><strong aria-hidden="true">5.2.1.</strong> Conference packets</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Tox Human Docs</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>TODO</p>
<p>TODO: Fill it with info about libsodium</p>
<p>TODO: copy from https://toktok.ltd/spec#crypto</p>
<p>TODO: copy from https://toktok.ltd/spec#dht</p>
<p>TODO: copy from https://toktok.ltd/spec#tcp-server</p>
<p>TODO</p>
<p>This is a description of onion layer in Tox.</p>
<h2><a class="header" href="#paths" id="paths">Paths</a></h2>
<p>Onion routing can be described using this chart:</p>
<p><img src="onion/../static/path.svg" alt="" /></p>
<p>To send a message via an onion path, first we construct the path by choosing three random nodes. Then, we put the message in several layers:</p>
<ol>
<li><code>OnionRequest2</code> contains the address of the message receiver and the message encrypted with the third's node key </li>
<li><code>OnionRequest1</code> contains the address of the second node and <code>OnionRequest2</code> encrypted with the second's node key, and</li>
<li><code>OnionRequest0</code> contains the address of the first node and encrypted <code>OnionRequest0</code></li>
</ol>
<p>A node that belongs to the path receives a message, decrypts the payload, attaches <code>OnionReturn</code> and sends the result to the next node in the path.</p>
<p>An <code>OnionReturn</code> of the n'th node is the pair of <code>IP_Port</code> and <code>OnionReturn</code> of the previous node (if it exists), encrypted with the n'th node's key. It allows the receiver to send a response to the sender using the same onion path.</p>
<h2><a class="header" href="#client-announce" id="client-announce">Client announce</a></h2>
<p>An iteration of self announce:</p>
<ol>
<li>Clean up the <code>announce_list</code> from timeouted nodes</li>
<li>For node <code>n</code> in <code>announce_list</code>:
<ul>
<li>If the node is out of ping credit, skip it</li>
<li>Check whether the node is not announced, announced or stable</li>
<li>If it's time to send an announce request, send it to the node
<ul>
<li>Update time and increment <code>ping_debt</code> of the node</li>
</ul>
</li>
</ul>
</li>
<li>If <code>announce_list</code> is not full, choose whether we should send to a path node
<ul>
<li>If so, send the announce request to a random path node (ping_id = 0)</li>
</ul>
</li>
</ol>
<p>A node is considered <em>timeouted</em>  if the last ping was more than <code>NODE_TIMEOUT</code> seconds ago and the node is out of ping credit.</p>
<p>A node is <em>out of ping credit</em> if <code>ping_debt</code> of the node is more than <code>MAX_NODE_PINGS</code>.</p>
<p>A node is <em>announced</em> if <code>is_stored</code> is not <code>0</code> and client's <code>self_paths</code> contains a path with the <code>path_num</code> of the node. An announced node is called <em>stable</em> if the node by itself is stable and the corresponding path is stable.</p>
<p>A node is <em>stable by itself</em> if it was added more than <code>TIME_TO_STABLE</code> seconds ago, its <code>ping_debt</code> is zero, the node was pinged less than <code>NODE_TIMEOUT</code> seconds ago.</p>
<p>A path is called <em>stable</em> if it was created more than <code>TIME_TO_STABLE</code> seconds ago, the <code>usage_debt</code> of the path is zero and the path was not used for more than <code>PATH_TIMEOUT</code>.</p>
<p>It is time to send an announce request if:</p>
<ol>
<li>A node was pinged more than <code>interval</code> seconds ago, where <code>interval</code> is one of <code>ANNOUNCE_INTERVAL_NOT_ANNOUNCED</code>, <code>ANNOUNCE_INTERVAL_ANNOUNCED</code>, <code>ANNOUNCE_INTERVAL_STABLE</code>, depending on the node type</li>
<li>Or the last announce was more than <code>NODE_PING_INTERVAL</code> seconds ago and <code>random(MAX_ONION_CLIENTS_ANNOUNCE - i) == 0</code>, where <code>i</code> is the index of the node in the <code>announce_list</code></li>
</ol>
<p>The process of sending a self announce request to a node is the following:</p>
<ol>
<li>First, get a random path with a given <code>path_num</code>.</li>
<li>Store a sendback in <code>announce_ping_array</code>, getting the sendback_id</li>
<li>Construct an announce request payload with
<ul>
<li><code>search_id = real_pk</code></li>
<li><code>data_pk = temp_pk</code></li>
<li><code>ping_id = ping_id</code></li>
<li><code>sendback_data = sendback_id</code>
<ul>
<li>Where <code>real_pk</code> is the real public key, <code>temp_pk</code> is the temporary public key of the onion client.</li>
</ul>
</li>
</ul>
</li>
<li>The payload is encrypted using <code>{dest_pk, real_sk}</code>, where <code>dest_pk</code> is the public key of the destination, <code>real_sk</code> is the real secret key</li>
<li>Construct the request with the payload and <code>{pk = real_pk}</code></li>
<li>Send the request via the onion path</li>
</ol>
<p>Getting a random path:</p>
<ol>
<li>If <code>path_num</code> is not <code>None</code>, set <code>path_index = path_num % NUMBER_ONION_PATHS</code>. Otherwise, set <code>path_index = random(0..NUMBER_ONION_PATHS)</code></li>
<li>If <code>path_list[path_index]</code> is timed out or doesn't exist:
<ol>
<li>Get <code>ONION_PATH_LENGTH</code> random path nodes</li>
<li>Check whether the last node belongs to some path</li>
<li>If yes, then use that path</li>
<li>If not:
<ol>
<li>Create a new onion path</li>
<li>Set times for the path</li>
<li>Set <code>path_num = r(random_u32(), NUMBER_ONION_PATHS) + path_index</code>, where \(r(a, n) = a - (a \bmod n)\) – a “modulo rounding” function</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise, just use the existing path</li>
<li>If the path is not out of usage credit, update <code>last_path_used</code></li>
<li>Increment the usage debt of the path</li>
<li>Return the path</li>
</ol>
<p>An announce response is handled in the following way:</p>
<ol>
<li>Get the sendback from <code>announce_ping_array</code> using the <code>sendback_data</code></li>
<li>Decrypt the payload using <code>{sb.node.pk, real_sk}</code>, where <code>sb.node.pk</code> is the public key stored in the sendback, <code>real_sk</code> is the real secret key</li>
<li>Set path timeouts using <code>{sb.friend_num, sb.path_num}</code></li>
<li>Add the announce node to <code>announce_list</code></li>
<li>Add the node to <code>path_nodes</code></li>
<li>Get nodes from the payload and ping them (if any)</li>
</ol>
<p>The process of pinging a node is the following:</p>
<ol>
<li>Clean up <code>announce_list</code> from timeouted nodes</li>
<li>A node in the payload is pinged if:
<ol>
<li>It is closer to us than nodes in the <code>announce_list</code> or the list is not full</li>
<li>And it doesn't belong to the list</li>
<li>And it is good to ping</li>
</ol>
</li>
<li>Pinging is sending an announce request with <code>ping_id = 0</code> via a random path</li>
</ol>
<p>A node is good to ping if this is not the last pinged node unless the node was pinged more than <code>MIN_NODE_PING_TIME</code> ago.</p>
<p>A sequence chart for the beginning of self announce process (messages are sent via onion):</p>
<p><img src="onion/../static/announce_start.svg" alt="" /></p>
<h2><a class="header" href="#friend-search-and-dhtpk-announce" id="friend-search-and-dhtpk-announce">Friend search and DHTPK announce</a></h2>
<p>The overall process has two steps:</p>
<ul>
<li>First, we use announce requests to find announce nodes that stores paths to our friend
<ul>
<li>This process is similar to the announce process</li>
</ul>
</li>
<li>Then, we send (via onion) <code>DataRequest</code> to found announce nodes</li>
</ul>
<p>This is the chart of the second step:</p>
<p><img src="onion/../static/dhtpk.svg" alt="" /></p>
<p>Specifically:</p>
<ol>
<li>We start with constructing <code>DhtPkData</code>:
<ul>
<li><code>no_replay = now</code> where <code>now</code> is the current time</li>
<li><code>dht_pk = dht_pk</code> where <code>dht_pk</code> is our dht public key</li>
<li><code>nodes = closest</code> where <code>closest</code> is a list of closest to us dht nodes</li>
</ul>
</li>
<li>Serialize it into bytes and send as an onion data or via dht</li>
</ol>
<p>The process of sending onion data is the following:</p>
<ol>
<li>The <code>client_list</code> of a friend is cleaned up of timeouted nodes</li>
<li>Good nodes are with <code>is_stored != 0</code></li>
<li>It should be more than <code>(num_nodes - 1) / 4 + 1</code> good nodes to continue where <code>num_nodes</code> is the number of nodes in <code>client_list</code></li>
<li>Generate a random nonce</li>
<li>The data is encrypted using friend's real public key, our real secret key and the nonce</li>
<li>Construct <code>OnionData</code>:
<ul>
<li><code>real_pk</code> is our real public key</li>
<li><code>dht_pk_data</code> is the encrypted data</li>
</ul>
</li>
<li>For each good node:
<ol>
<li>Get a random friend path</li>
<li>Construct a <code>DataRequest</code>:
<ul>
<li><code>dest_pk = friend.real_pk</code></li>
<li><code>nonce = nonce</code>. The same nonce that we used before</li>
<li><code>temp_pk = random_pk</code>. We generate a random keypair</li>
<li>The <code>payload</code> is the onion data encryped with the node's data public key and the random secret key, using the same <code>nonce</code></li>
</ul>
</li>
<li>Send the request via the onion path</li>
</ol>
</li>
</ol>
<h2><a class="header" href="#notes-on-data-structures" id="notes-on-data-structures">Notes on data structures</a></h2>
<p>Both <code>path_nodes</code> and <code>announce_list</code> are arrays of limited size. But the way they are updated are different.</p>
<p>When <code>path_nodes</code> is full, adding a new element replaces an old one in a circular manner: first adding an element replaces <code>path_nodes[0]</code>, then <code>path_nodes[1]</code>, and so on til we get to the end of the array. After that, we begin again with <code>path_nodes[0]</code>.</p>
<p><code>announce_list</code> is different. It is sorted by distance to real our public key. When an element is added, it is checked against the farest node. If the element is closer to us than the node, the node is removed and the element is inserted. Otherwise, the element is simply discarded.</p>
<p>Some packet data structures:</p>
<pre><code>struct DhtPkData {
    no_replay: u64,
    dht_pk: PublicKey,
    nodes: Vec&lt;PackedNode&gt;,
}

layout DhtPkData {
    u8 = ONION_DATA_DHTPK,
    u64,
    [u8; PUBLIC_KEY_SIZE],
    [[u8; PACKED_NODE_SIZE]; 0..MAX_SENT_NODES]
}
</code></pre>
<h2><a class="header" href="#toxcore-notes" id="toxcore-notes">Toxcore notes</a></h2>
<p>In the C implementation, <code>ping_debt</code> and <code>usage_debt</code> are called <code>unsuccessful_pings</code> and <code>last_path_used_times</code> correspondingly. New names are chosen to represent the meaning of these variables more clearly.</p>
<p>TODO</p>
<p>This is a description of packets of messenger layer of Tox.</p>
<h2><a class="header" href="#file_sendrequest" id="file_sendrequest">FILE_SENDREQUEST</a></h2>
<p>This packet is used to initiate transferring sender's data file or avatar file to a friend.
Toxcore doesn't accumulate file chunks, accumulating file chunks is role of client.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x50</code></td></tr>
<tr><td><code>1</code></td><td><code>file_id</code></td></tr>
<tr><td><code>4</code></td><td><code>file_type</code>(0 = data, 1 = avatar image data)</td></tr>
<tr><td><code>8</code></td><td><code>file_size</code></td></tr>
<tr><td><code>32</code></td><td><code>file_unique_id</code>(a random bytes)</td></tr>
<tr><td><code>0.255</code></td><td><code>file_name</code> as UTF-8 C string</td></tr>
</tbody></table>
<p><code>file_type</code> and <code>file_size</code> are sent in big endian format.</p>
<h2><a class="header" href="#file_data" id="file_data">FILE_DATA</a></h2>
<p>FileData packet is used to transfer sender's data file to a friend.
It holds <code>file_id</code> which is one byte long, means that a tox client can send maximum 256 files concurrently.
Also it means that two friends can send 512 files to each other concurrently.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x52</code></td></tr>
<tr><td><code>1</code></td><td><code>file_id</code></td></tr>
<tr><td><code>0..1371</code></td><td>file data piece</td></tr>
</tbody></table>
<p>One FileData packet can hold maximum 1371 bytes.
To send whole file which is bigger than 1371 bytes, messenger's file sending function need to be called many times.
Multiple calling file sending function of messenger must be done by the user of tox protocol, Tox-rs provides only an api for sending a chunk of file data.
Also, assembling chunks of file data received by tox protocol must be done by the user of tox protocol.
File sending module always checks the length of sent bytes by length of file to send.
When the sent bytes exceed the length of file to send, it must stop sending file data.</p>
<h2><a class="header" href="#file_control" id="file_control">FILE_CONTROL</a></h2>
<p>This packet is used to control transferring sender's file to a friend.
If a peer of connection wants to pause, kill, seek or accept transferring file, it must use this packet.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x51</code></td></tr>
<tr><td><code>1</code></td><td>Whether it is sending or receiving, 0 = sender, 1 = receiver</td></tr>
<tr><td><code>1</code></td><td><code>file_id</code></td></tr>
<tr><td><code>1</code></td><td>Control type: 0 = accept, 1 = pause, 2 = kill, 3 = seek</td></tr>
<tr><td><code>8</code></td><td>Seek parameter which is only included when <code>control type</code> is seek(3)</td></tr>
</tbody></table>
<p>When messenger layer is called by user using FILE_CONTROL, it checks:</p>
<ul>
<li>Sending direction value is <code>0</code> or <code>1</code> means 0 = sender, 1 = receiver, others = error</li>
<li>Retrieves <code>file transfer object</code> which holds info of file transferring, if it fails then send FileControl packet to a friend to kill the session.</li>
<li><code>file transfer object</code> is managed by <code>file_id</code> and <code>friend_id</code> and <code>sending direction</code>.</li>
</ul>
<p>FILE_CONTROL do following things:</p>
<ul>
<li>
<p>Accept: Accept the request of file sending from a friend. It does:</p>
<ul>
<li>checks if status is not <code>Accepted</code> if it is not <code>Accepted</code> then
<ul>
<li>change status to <code>Transferring</code></li>
</ul>
</li>
<li>else checks:
<ul>
<li>if status is <code>Pause by friend</code> then toggle status of <code>Pause by friend</code></li>
<li>else error because friend asked me to resume file transfer that wasn't paused.</li>
</ul>
</li>
<li>updates <code>file transfer object</code></li>
</ul>
</li>
<li>
<p>Pause: Pause the transfer. It does:</p>
<ul>
<li>checks if pause status is <code>Paused by friend</code> or transfer status is not <code>Transferring</code> then
error because friend asked me to pause transfer that is already paused.</li>
<li>toggles pause status</li>
<li>updates <code>file transfer object</code></li>
</ul>
</li>
<li>
<p>Kill: Kill the transfer session. It does:</p>
<ul>
<li>updates <code>file transfer object</code></li>
<li>set transfer status to <code>None</code></li>
<li>decreases count of friend's number of sending files</li>
</ul>
</li>
<li>
<p>Seek: Seek to the position. It does:</p>
<ul>
<li>checks if the transfer status is <code>Accepted</code> and the sender of this packet is receiver of file data
<ul>
<li>else error because Seek must be used to session <code>Accepted</code> and Seek packet can only be sent by receiver to seek before resuming broken transfers.</li>
</ul>
</li>
<li>checks if the position exceeds the file size, if it exceeds
<ul>
<li>error because seek position exceeds file size.</li>
</ul>
</li>
<li>set <code>requested position</code> and <code>transferred position</code> to seek position.</li>
</ul>
</li>
<li>
<p>else error because invalid file control command.</p>
</li>
</ul>
<h2><a class="header" href="#typing" id="typing">TYPING</a></h2>
<p>This packet is used to transmit sender's typing status to a friend.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x33</code></td></tr>
<tr><td><code>1</code></td><td>Typing status(0 = not typing, 1 = typing)</td></tr>
</tbody></table>
<p>It checks if the data is one bytes, and update typing status to the value of data.</p>
<h2><a class="header" href="#action" id="action">ACTION</a></h2>
<p>This packet is used to transmit sender's action message to a friend.
Here, action message is a something like an IRC action.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x41</code></td></tr>
<tr><td><code>0..1372</code></td><td>UTF8 byte string</td></tr>
</tbody></table>
<p>It checks if the action message is empty, if it is then do nothing else sends the action message to the friend.
It is C string.</p>
<h2><a class="header" href="#message" id="message">MESSAGE</a></h2>
<p>This packet is used to transmit sender's message to a friend.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x40</code></td></tr>
<tr><td><code>0..1372</code></td><td>UTF8 byte string</td></tr>
</tbody></table>
<p>There is no zero-length or empty string allowed and if it is then do nothing.
It is C string.</p>
<h2><a class="header" href="#status_message" id="status_message">STATUS_MESSAGE</a></h2>
<p>This packet is used to transmit sender's status message to a friend.
Every time a friend become online or my status message is changed,
this packet is sent to the friend or to all friends of mine.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x31</code></td></tr>
<tr><td><code>0..1007</code></td><td>UTF8 byte string</td></tr>
</tbody></table>
<p>If packet is received then call registered callback function to change the status message of the friend and
change the status data for the friend.
It is C string.</p>
<h2><a class="header" href="#user_status" id="user_status">USER_STATUS</a></h2>
<p>This packet is used to transmit sender's status to a friend.
Every time a friend become online or my status is changed,
this packet is sent to the friend or to all friends of mine.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x32</code></td></tr>
<tr><td><code>1</code></td><td>My status(0 = online, 1 = away, 2 = busy)</td></tr>
</tbody></table>
<p>When a node receives this packet, it call registered callback function to change the status of the friend.</p>
<h2><a class="header" href="#msi" id="msi">MSI</a></h2>
<p>MSI(Media Session Interface) is a protocol to manage audio or video calls to a friend(s).
Payload of a msi packet consists of three kinds of sub-packets: request, error, capabilities.</p>
<ul>
<li>
<p>Request does:</p>
<ul>
<li>init_call.</li>
<li>push: start call or change capabilities or report error.</li>
<li>pop: end call or adopt capabilities or process error.</li>
</ul>
</li>
<li>
<p>Error is used to report errors during av-call setup, running, terminating.</p>
</li>
<li>
<p>Capabilities hold the ability of node related with audio, video.</p>
</li>
<li>
<p>One msi packet must have at least 2 sub-packets: request and capabilities(error sub-packet is optional).</p>
<ul>
<li>Optional means if there is no error then msi packet need not include error sub-packet in its payload.</li>
</ul>
</li>
<li>
<p>When a node receives msi packet, it performs the request sub-packet with capabilities sub-packet.</p>
<ul>
<li>For example, if the request is REQU_INIT and capabilities is full option then node initializes a call with capabilities of sending audio, receiving audio, sending video, receiving video.</li>
<li>During REQU_INIT, if the node's capabilities changed to audio only, then the node sends REQU_PUSH with capabilities of sending audio and receiving audio(2 sub-packets).</li>
<li>If there is an error for changing capabilities, the msi packet would include error sub-packet, so there are 3 sub-packets in payload of a msi packet(REQU_PUSH, capabilities, error).</li>
</ul>
</li>
<li>
<p>A node holds its capabilities in local variable, if the capabilities of received packet differ from saved value then apply changes and update local variable.</p>
</li>
<li>
<p>If error sub-packet is included in received msi packet then process error.</p>
</li>
</ul>
<p>Sub-packet: kind [1 byte], size [1 byte], value [$size bytes] : but actually size is always 1, so a sub-packet is always 3 bytes long</p>
<ul>
<li>kind: one of Request, Capabilities, Error</li>
<li>size: the length in byte of value(always 1)</li>
<li>value: enum value depending on kind</li>
</ul>
<p>Payload: |sub_packet| |...{sub-packet}| |0|</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x45</code></td></tr>
<tr><td><code>0..255</code></td><td>payload</td></tr>
</tbody></table>
<p>Sub-packet serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td>kind(1 = Request, 2 = Error, 3 = Capabilities)</td></tr>
<tr><td><code>1</code></td><td>size(always 1)</td></tr>
<tr><td><code>1</code></td><td>value(it depends on kind)</td></tr>
</tbody></table>
<p>If kind is Request then value is one of these</p>
<ul>
<li>REQU_INIT = 0</li>
<li>REQU_PUSH = 1</li>
<li>REQU_POP = 2</li>
</ul>
<p>If kind is Error then value is one of these</p>
<ul>
<li>MSI_E_NONE = 0</li>
<li>MSI_E_INVALID_MESSAGE = 1</li>
<li>MSI_E_INVALID_PARAM = 2</li>
<li>MSI_E_INVALID_STATE = 3</li>
<li>MSI_E_STRAY_MESSAGE = 4</li>
<li>MSI_E_SYSTEM = 5</li>
<li>MSI_E_HANDLE = 6</li>
<li>MSI_E_UNDISCLOSED = 7</li>
</ul>
<p>If kind is Capabilities then value is bitwise-OR of these</p>
<ul>
<li>MSI_CAP_S_AUDIO = 4,  // sending audio</li>
<li>MSI_CAP_S_VIDEO = 8,  // sending video</li>
<li>MSI_CAP_R_AUDIO = 16, // receiving audio</li>
<li>MSI_CAP_R_VIDEO = 32, // receiving video</li>
</ul>
<p>Examples of payload are</p>
<ul>
<li>Request(REQU_INIT) + capabilities(audio &amp; video) = 6 bytes</li>
<li>Request(REQU_INIT) + capabilities(audio) + error = 9 bytes</li>
<li>Request(REQU_PUSH) + capabilities(video) + Request(REQU_POP) + error = 12 bytes</li>
<li>Request(REQU_PUSH) + Request(REQU_POP) + Request(REQU_INIT) + capabilities(audio) + error(MSI_E_SYSTEM) + error(MSI_E_HANDLE) = 18 bytes</li>
</ul>
<p>This packet structure can permit for a node to send multiple sub-packets in one packet.
For example a node can send packet to a friend to start call with capabilities and errors.
The node receiving this packet also can do multiple action on sub-packets in a packet.
Because <code>payload</code> size is 255 bytes long, we can send maximum 255 / 3 = 85 sub-packets in a packet.</p>
<p>If there are same kind of sub-packets in a packet, the last sub-packet will replace the previous sub-packet. so the result of parsing above examples are</p>
<ul>
<li>Request(REQU_INIT) + capabilities(audio &amp; video)</li>
<li>Request(REQU_INIT) + capabilities + error</li>
<li>Request(REQU_POP) + capabilities + error</li>
<li>Request(REQU_INIT) + capabilities + error(MSI_E_HANDLE)</li>
</ul>
<p>After parsing payload, there are only last sub-packets of each kind.</p>
<h5><a class="header" href="#callstate" id="callstate">CallState</a></h5>
<p>A node maintains internal call_state variable, call_state is one of these</p>
<ul>
<li>MSI_CALL_INACTIVE = 0      // Default</li>
<li>MSI_CALL_ACTIVE = 1</li>
<li>MSI_CALL_REQUESTING = 2    // when sending call invite</li>
<li>MSI_CALL_REQUESTED = 3     // when getting call invite</li>
</ul>
<p>On receiving this packet, a node does:</p>
<ul>
<li>parse packet: parse it to store sub-packets to data structures.
<ul>
<li>Data structure which holds the result of parsing has 3 fields
<ul>
<li><code>Request</code> holds request sub-packet</li>
<li><code>Error</code> holds error during processing sub-packet.</li>
<li><code>Capabilities</code> holds the abilities related with audio or video of a friend.</li>
</ul>
</li>
<li>If there are same kind of sub-packets in a packet, the last sub-packet will replace the previous one.</li>
</ul>
</li>
<li>Process the <code>Request</code> sub-packet in the packet.
<ul>
<li>Init: init a msi session.
<ul>
<li>Check if <code>Capaboilites</code> is empty, if it is then return with error(<code>MSI_E_INVALID_MESSAGE</code>).</li>
<li>If call_state is <code>MSI_CALL_INACTIVE</code> then requests a call to a friend.</li>
<li>If call_state is <code>MSI_CALL_ACTIVE</code> then sends packet containing capabilities of us. This is the situation of a friend re-call us
but we are not terminated with previous call.</li>
<li>If call_state is <code>MSI_CALL_REQUESTING</code> or <code>MSI_CALL_REQUESTED</code> then return with error(<code>MSI_E_INVALID_STATE</code>).</li>
</ul>
</li>
<li>Push: Starts a new call to a friend or change capabilities.
<ul>
<li>Check if <code>Capaboilites</code> is empty, if it is then return with error(<code>MSI_E_INVALID_MESSAGE</code>).</li>
<li>If call_state is <code>MSI_CALL_ACTIVE</code> then check if capabilities are changed from previous value, if it is then
change current call's capabilities.</li>
<li>If call_state is <code>MSI_CALL_REQUESTING</code> then  starts a new call</li>
<li>If call_state is <code>MSI_CALL_INACTIVE</code> or <code>MSI_CALL_REQUESTED</code> then ignore it.</li>
</ul>
</li>
<li>Pop: Ends current call
<ul>
<li>If there is a error command in the packet then terminates current call.</li>
<li>If call_state is <code>MSI_CALL_INACTIVE</code> then it is a impossible case. So, terminates process.</li>
<li>If call_state is <code>MSI_CALL_ACTIVE</code> then it is a hang-up of a friend. So, ends call.</li>
<li>If call_state is <code>MSI_CALL_REQUESTING</code> then it is a rejection of call by a friend. So, ends call.</li>
<li>If call_state is <code>MSI_CALL_REQUESTED</code> then it is a cancelling of a call request by a friend. So, ends call.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>When we need to send a packet to a friend, a node does:</p>
<ul>
<li>creates a new object which is one of these:
<ul>
<li>Init</li>
<li>Push</li>
<li>Pop</li>
</ul>
</li>
<li>adds error sub-packet if there is an error</li>
<li>adds capabilities sub-packet of us</li>
<li>creates a msi packet using above object and sends it using <code>NetCrypto</code></li>
</ul>
<h2><a class="header" href="#online" id="online">ONLINE</a></h2>
<p>Sent to a friend when a connection is established.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x18</code></td></tr>
</tbody></table>
<h2><a class="header" href="#offline" id="offline">OFFLINE</a></h2>
<p>Sent to a friend when deleting the friend. It the friend is a member of a groupchat, we show the node as <code>offline</code>.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x19</code></td></tr>
</tbody></table>
<h2><a class="header" href="#nickname" id="nickname">NICKNAME</a></h2>
<p>Used to send the nickname of the peer to others. Whenever a friend comes online, this packet should be sent or whenever my nickname is changed, this packet should be sent.</p>
<p>Serialized form:</p>
<table><thead><tr><th>Length</th><th>Content</th></tr></thead><tbody>
<tr><td><code>1</code></td><td><code>0x30</code></td></tr>
<tr><td><code>0..128</code></td><td>UTF-8 C string</td></tr>
</tbody></table>
<p>TODO</p>
<h1><a class="header" href="#conference-packets" id="conference-packets">Conference packets</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
